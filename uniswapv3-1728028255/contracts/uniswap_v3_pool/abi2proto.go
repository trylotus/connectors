package uniswap_v3_pool

import (
	"fmt"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/rs/zerolog/log"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/timestamppb"
	"github.com/trylotus/go-connector/common"
)

type SmartContract struct {
	Addr string
	Abi  abi.ABI
}

func NewContract(addr string) *SmartContract {
	contractAbi, err := abi.JSON(strings.NewReader(UniswapV3PoolMetaData.ABI))
	if err != nil {
		log.Fatal().Err(err).Msg("error reading abi")
	}
	return &SmartContract{Addr: addr, Abi: contractAbi}
}

func (c *SmartContract) Address() string {
	return c.Addr
}

func (c *SmartContract) Message(vLog types.Log, ts *timestamppb.Timestamp) (proto.Message, error) {
	ev, err := c.Abi.EventByID(vLog.Topics[0])
	if err != nil {
		return nil, fmt.Errorf("cannot find event by ID: %v", err)
	}
	switch ev.Name {

/* Code generated by https://github.com/trylotus/connector-bot. DO NOT EDIT */



case "CollectProtocol":
	event := new(UniswapV3PoolCollectProtocol)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &CollectProtocol{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Recipient: event.Recipient.Bytes(),
		Sender: event.Sender.Bytes(),
	}


	return protoMsg, nil


case "Flash":
	event := new(UniswapV3PoolFlash)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Flash{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Paid0: event.Paid0.String(),
		Paid1: event.Paid1.String(),
		Recipient: event.Recipient.Bytes(),
		Sender: event.Sender.Bytes(),
	}


	return protoMsg, nil


case "Burn":
	event := new(UniswapV3PoolBurn)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Burn{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount: event.Amount.String(),
		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Owner: event.Owner.Bytes(),
		TickLower: event.TickLower.String(),
		TickUpper: event.TickUpper.String(),
	}


	return protoMsg, nil


case "IncreaseObservationCardinalityNext":
	event := new(UniswapV3PoolIncreaseObservationCardinalityNext)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &IncreaseObservationCardinalityNext{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		ObservationCardinalityNextNew: uint32(event.ObservationCardinalityNextNew),
		ObservationCardinalityNextOld: uint32(event.ObservationCardinalityNextOld),
	}


	return protoMsg, nil


case "Initialize":
	event := new(UniswapV3PoolInitialize)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Initialize{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		SqrtPriceX96: event.SqrtPriceX96.String(),
		Tick: event.Tick.String(),
	}


	return protoMsg, nil


case "Mint":
	event := new(UniswapV3PoolMint)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Mint{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount: event.Amount.String(),
		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Owner: event.Owner.Bytes(),
		Sender: event.Sender.Bytes(),
		TickLower: event.TickLower.String(),
		TickUpper: event.TickUpper.String(),
	}


	return protoMsg, nil


case "SetFeeProtocol":
	event := new(UniswapV3PoolSetFeeProtocol)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &SetFeeProtocol{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		FeeProtocol0New: uint32(event.FeeProtocol0New),
		FeeProtocol0Old: uint32(event.FeeProtocol0Old),
		FeeProtocol1New: uint32(event.FeeProtocol1New),
		FeeProtocol1Old: uint32(event.FeeProtocol1Old),
	}


	return protoMsg, nil


case "Swap":
	event := new(UniswapV3PoolSwap)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Swap{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Liquidity: event.Liquidity.String(),
		Recipient: event.Recipient.Bytes(),
		Sender: event.Sender.Bytes(),
		SqrtPriceX96: event.SqrtPriceX96.String(),
		Tick: event.Tick.String(),
	}


	return protoMsg, nil


case "Collect":
	event := new(UniswapV3PoolCollect)
	if err := common.UnpackLog(c.Abi, event, ev.Name, vLog); err != nil {
		return nil, fmt.Errorf("error unpacking event: %s", ev.Name)
	}
	protoMsg := &Collect{
		Ts:          ts,
		BlockNumber: vLog.BlockNumber,
		TxHash:      vLog.TxHash.Bytes(),
		LogIndex:       uint64(vLog.Index),

		Amount0: event.Amount0.String(),
		Amount1: event.Amount1.String(),
		Owner: event.Owner.Bytes(),
		Recipient: event.Recipient.Bytes(),
		TickLower: event.TickLower.String(),
		TickUpper: event.TickUpper.String(),
	}


	return protoMsg, nil



/* Code generated by https://github.com/trylotus/connector-bot. DO NOT EDIT */

	default:
		return nil, fmt.Errorf("invalid event: %s", ev.Name)
	}
}
